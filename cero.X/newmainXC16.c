/*
 * File:   newmainXC16.c
 * Author: pabloelmalo
 *
 * Created on 8 de junio de 2016, 13:16
 */


#include "xc.h"
#include "newxc16_header.h"
#include <dsp.h>

#define HIGH 1
#define LOW 0

extern IIRTransposedStruct ExampleHPFFilter;

extern void IIRTransposedInit(IIRTransposedStruct* filter);

extern fractional* IIRTransposed(int numSamps, fractional* dstSamps, fractional* srcSamps, IIRTransposedStruct* filter);
//    IIRTransposed (numSamps,*dstSamps,*srcSamps,*filter) || biquad filtering
//                                        
//    numSamps || number of input samples (N)
//    dstSamps || ptr to output samples (y[n], 0 <= n < N)
//    srcSamps || ptr to input samples (x[n], 0 <= n < N)
//    filter   || Transposed biquad filter structure
//    returns dstSamps

extern fractional* VectorAdd (int numElems, fractional* dstV, fractional* srcV1, fractional* srcV2);
//fractional* VectorAdd (int numElems, fractional* dstV, fractional* srcV1, fractional* srcV2);
//
//numElems number of elements in source vector
//dstV pointer to destination vector
//srcV1 pointer to source one vector
//srcV2 pointer to source two vector

extern fractional* VectorMultiply (int numElems, fractional* dstV, fractional* srcV1, fractional* srcV2);
//fractional* VectorMultiply (int numElems, fractional* dstV, fractional* srcV1, fractional* srcV2)
//
//numElems number of elements in source vector
//dstV pointer to destination vector
//srcV1 pointer to source one vector
//srcV2 pointer to source two vector

extern fractional* VectorCopy (int numElems,fractional* dstV,fractional* srcV);
//extern fractional* VectorCopy (int numElems,fractional* dstV,fractional* srcV);
//
//numElems number of elements in source vector
//dstV pointer to destination vector
//srcV pointer to source one vector


int main(void) {
    
// Configure Oscillator to operate the device at 40Mhz
// Fosc= Fin*M/(N1*N2), Fcy=Fosc/2
// Fosc= 3.9M*41/(2*2)=40Mhz for 3.9M input clock
    
    PLLFBD=41;                              // M=41
    CLKDIVbits.PLLPOST=0;                   // N2=2
    CLKDIVbits.PLLPRE=0;                    // N1=2
    OSCTUN=0;

    // Disable Watch Dog Timer
	RCONbits.SWDTEN=0;
    
    // Inicializado de puerto para señales de debug y salidas del SPI
    TRISA = 0x0002; // 0000 0010 define la A1 como entrada y las demas como salida
    LATA  = 0x0002; // escribe en el latch del puerto A
    
    
    fractional dstSamps[192]; // vector destino de las muestras
    fractional piloto[]={0x4a8f,0x7935,0x7a7d,0x4dec,0x0430,0xb8e3,0x8834,0x845d,0xaecc,0xf7a1,0x4398,0x7642,0x7ca8,0x5465,0x0c8c,0xc000,0x8b69,0x8276,0xa880,0xef4b,0x3c57,0x72cd,0x7e4a,0x5a82,0x14da,0xc763,0x8f1d,0x8118,0xa294,0xe707,0x34d4,0x6eda,0x7f62,0x603c,0x1d11,0xcf04,0x934d,0x8046,0x9d0e,0xdedf,0x2d17,0x6a6e,0x7fee,0x658d,0x2528,0xd6db,0x97f5,0x8000,0x97f5,0xd6db,0x2528,0x658d,0x7fee,0x6a6e,0x2d17,0xdedf,0x9d0e,0x8046,0x934d,0xcf04,0x1d11,0x603c,0x7f62,0x6eda,0x34d4,0xe707,0xa294,0x8118,0x8f1d,0xc763,0x14da,0x5a82,0x7e4a,0x72cd,0x3c57,0xef4b,0xa880,0x8276,0x8b69,0xc000,0x0c8c,0x5465,0x7ca8,0x7642,0x4398,0xf7a1,0xaecc,0x845d,0x8834,0xb8e3,0x0430,0x4dec,0x7a7d,0x7935,0x4a8f,0x0000,0xb571,0x86cb,0x8583,0xb214,0xfbd0,0x471d,0x77cc,0x7ba3,0x5134,0x085f,0xbc68,0x89be,0x8358,0xab9b,0xf374,0x4000,0x7497,0x7d8a,0x5780,0x10b5,0xc3a9,0x8d33,0x81b6,0xa57e,0xeb26,0x389d,0x70e3,0x7ee8,0x5d6c,0x18f9,0xcb2c,0x9126,0x809e,0x9fc4,0xe2ef,0x30fc,0x6cb3,0x7fba,0x62f2,0x2121,0xd2e9,0x9592,0x8012,0x9a73,0xdad8,0x2925,0x680b,0x7fff,0x680b,0x2925,0xdad8,0x9a73,0x8012,0x9592,0xd2e9,0x2121,0x62f2,0x7fba,0x6cb3,0x30fc,0xe2ef,0x9fc4,0x809e,0x9126,0xcb2c,0x18f9,0x5d6c,0x7ee8,0x70e3,0x389d,0xeb26,0xa57e,0x81b6,0x8d33,0xc3a9,0x10b5,0x5780,0x7d8a,0x7497,0x4000,0xf374,0xab9b,0x8358,0x89be,0xbc68,0x085f,0x5134,0x7ba3,0x77cc,0x471d,0xfbd0,0xb214,0x8583,0x86cb,0xb571,0x0000};
    fractional piloto_pablo[]={0x0,0x77d,0xc25,0xc36,0x7a8,0x35,0xf8af,0xf3ec,0xf3bb,0xf82d,0xff95,0x725,0xc02,0xc54,0x7fd,0xa0,0xf908,0xf411,0xf39e,0xf7d9,0xff2a,0x6cb,0xbdb,0xc6f,0x850,0x10b,0xf963,0xf43a,0xf385,0xf788,0xfebf,0x66f,0xbb1,0xc87,0x8a0,0x176,0xf9bf,0xf465,0xf36f,0xf739,0xfe55,0x612,0xb84,0xc9b,0x8ee,0x1e0,0xfa1e,0xf494,0xf35c,0xf6ec,0xfdeb,0x5b2,0xb53,0xcac,0x93a,0x24a,0xfa7e,0xf4c6,0xf34d,0xf6a2,0xfd81,0x552,0xb20,0xcb9,0x983,0x2b3,0xfadf,0xf4fb,0xf341,0xf65a,0xfd18,0x4ef,0xae9,0xcc3,0x9c9,0x31c,0xfb42,0xf533,0xf339,0xf615,0xfcb0,0x48c,0xab0,0xcc9,0xa0d,0x383,0xfba6,0xf56e,0xf335,0xf5d2,0xfc49,0x427,0xa73,0xccc,0xa4e,0x3ea,0xfc0c,0xf5ac,0xf334,0xf593,0xfbe3,0x3c1,0xa34,0xccb,0xa8c,0x44f,0xfc72,0xf5ed,0xf336,0xf556,0xfb7e,0x35a,0x9f2,0xcc7,0xac7,0x4b4,0xfcda,0xf630,0xf33c,0xf51c,0xfb1b,0x2f2,0x9ad,0xcbf,0xb00,0x517,0xfd42,0xf676,0xf346,0xf4e5,0xfab8,0x289,0x966,0xcb4,0xb35,0x578,0xfdab,0xf6bf,0xf353,0xf4b2,0xfa57,0x220,0x91c,0xca6,0xb67,0x5d9,0xfe15,0xf70a,0xf363,0xf481,0xf9f8,0x1b6,0x8cf,0xc93,0xb96,0x637,0xfe7f,0xf758,0xf377,0xf453,0xf99a,0x14b,0x880,0xc7e,0xbc2,0x694,0xfeea,0xf7a8,0xf38e,0xf429,0xf93e,0xe1,0x82f,0xc65,0xbeb,0x6ef,0xff55,0xf7fb,0xf3a9,0xf402,0xf8e4,0x75,0x7db,0xc48,0xc10,0x748,0xffc0,0xf84f,0xf3c7,0xf3de,0xf88c};
    fractional subportadora[]={0x0,0x77d,0xc25,0xc36,0x7a8,0x35,0xf8af,0xf3ec,0xf3bb,0xf82d,0xff95,0x725,0xc02,0xc54,0x7fd,0xa0,0xf908,0xf411,0xf39e,0xf7d9,0xff2a,0x6cb,0xbdb,0xc6f,0x850,0x10b,0xf963,0xf43a,0xf385,0xf788,0xfebf,0x66f,0xbb1,0xc87,0x8a0,0x176,0xf9bf,0xf465,0xf36f,0xf739,0xfe55,0x612,0xb84,0xc9b,0x8ee,0x1e0,0xfa1e,0xf494,0xf35c,0xf6ec,0xfdeb,0x5b2,0xb53,0xcac,0x93a,0x24a,0xfa7e,0xf4c6,0xf34d,0xf6a2,0xfd81,0x552,0xb20,0xcb9,0x983,0x2b3,0xfadf,0xf4fb,0xf341,0xf65a,0xfd18,0x4ef,0xae9,0xcc3,0x9c9,0x31c,0xfb42,0xf533,0xf339,0xf615,0xfcb0,0x48c,0xab0,0xcc9,0xa0d,0x383,0xfba6,0xf56e,0xf335,0xf5d2,0xfc49,0x427,0xa73,0xccc,0xa4e,0x3ea,0xfc0c,0xf5ac,0xf334,0xf593,0xfbe3,0x3c1,0xa34,0xccb,0xa8c,0x44f,0xfc72,0xf5ed,0xf336,0xf556,0xfb7e,0x35a,0x9f2,0xcc7,0xac7,0x4b4,0xfcda,0xf630,0xf33c,0xf51c,0xfb1b,0x2f2,0x9ad,0xcbf,0xb00,0x517,0xfd42,0xf676,0xf346,0xf4e5,0xfab8,0x289,0x966,0xcb4,0xb35,0x578,0xfdab,0xf6bf,0xf353,0xf4b2,0xfa57,0x220,0x91c,0xca6,0xb67,0x5d9,0xfe15,0xf70a,0xf363,0xf481,0xf9f8,0x1b6,0x8cf,0xc93,0xb96,0x637,0xfe7f,0xf758,0xf377,0xf453,0xf99a,0x14b,0x880,0xc7e,0xbc2,0x694,0xfeea,0xf7a8,0xf38e,0xf429,0xf93e,0xe1,0x82f,0xc65,0xbeb,0x6ef,0xff55,0xf7fb,0xf3a9,0xf402,0xf8e4,0x75,0x7db,0xc48,0xc10,0x748,0xffc0,0xf84f,0xf3c7,0xf3de,0xf88c};
    fractional dstSUM[191];
    
    IIRTransposedInit(&ExampleHPFFilter);
        
    while(1){
        
        IIRTransposed(192,dstSamps,piloto,&ExampleHPFFilter);
        LATAbits.LATA0 = ~LATAbits.LATA0; // medido con el osciloscopio es lo mismo hacer el on/off que togglear
//        VectorAdd(191,dstSUM,piloto_pablo,subportadora);
//        VectorMultiply(191,dstSUM,piloto_pablo,subportadora);
//        VectorCopy(191,dstSUM,piloto_pablo);
    }
    
    return 0;
}
